# [TIL] 도서관 시스템 구현으로 배우는 Python 예외 처리와 OOP

## 1. 도서관 시스템 구현에 사용된 Python 내장 예외문

데이터가 서비스에서 허용하는 형식에 맞는지, 논리적으로 타당한지 확인하는 과정에서 다음과 같은 예외들을 사용합니다.

| 예외 이름 | 의미 | 도서관 상황 예시 |
| :--- | :--- | :--- |
| **ValueError** | 타입은 맞으나 **내용물(값)**이 적절하지 않음 | 이름 입력 시 공백 입력, 나이 입력 시 5살 미만 입력 등 |
| **KeyError** | Dictionary 상자 안에서 특정 **이름표(Key)**를 찾지 못함 | `self.members` 사전에서 등록되지 않은 이름을 찾으려 할 때 |
| **FileNotFoundError** | 지정한 경로에 **파일이 존재하지 않음** | `books.csv` 파일을 읽으려는데 파일이 삭제되었거나 이름이 틀렸을 때 |
| **LookupError** | 무언가를 **찾으려고(Lookup) 시도**했으나 실패함 | ISBN 번호로 검색했는데 일치하는 도서가 단 한 권도 없을 때 |
| **RuntimeError** | 문법과 값은 맞으나 **현재 프로그램 상태**와 맞지 않음 | 책은 존재하지만 이미 대출된 상태라 대출이 불가능할 때 |
| **Exception** | 모든 에러를 아우르는 **조상님** | 예상치 못한 모든 상황을 대비한 최후의 그물 |

---

## 2. 객체 지향 프로그래밍 (OOP)
프로그램을 데이터와 행위를 하나의 집합으로 모아 관리하는 방식입니다.

### 🔹 객체 (Object / Instance)
* 서로 연관된 데이터와 그 데이터를 조작하기 위한 함수를 하나의 집합에 모아놓은 것입니다.
* 집합의 원소가 되는 변수나 함수는 **멤버(Member)** 또는 **속성(Attribute)**이라고 합니다.
* 객체의 속성인 함수는 **메서드(Method)**라고 부릅니다.

### 🔹 클래스 (Class)
```python
class Rectangle(object):
		def __init__(self, h, v):
				self.h = h
				self.v = v
				
		def area(self):
				return self.h * self.v
```     
* 객체를 만들기 위한 설계도입니다. 클래스를 만든 후 이를 이용하여 객체를 생성합니다.
* 예: `Rectangle`은 클래스이고, `r = Rectangle(10, 20)`으로 만들어진 `r`은 객체입니다.
> r = Rectangle(10, 20)
>
> a = r.area()
>
> print(a)
>
> #결과: 200

### 🔹 생성자 (Constructor)
```python
class 클래스이름(object):
		def __init__(self, 속성값1, 속성값2, 속성값3):
				self.속성이름1 = 속성값1
				self.속성이름2 = 속성값2
				self.속성이름3 = 속성값3
```
* `__init__` 함수를 말하며 클래스 정의에서 가장 중요한 함수입니다.
* 클래스 이름을 호출하여 객체를 생성할 때 실제로는 이 생성자 함수가 호출되어 속성값을 저장합니다.

### 🔹 상속 (Inheritance)
* 부모 클래스(Super class)의 내용을 자식 클래스(Child class)가 물려받는 것입니다.
* 부모의 속성과 메서드를 그대로 사용할 수 있어 코드 재사용성이 높아집니다.

---

## 3. 매직 메소드 (Magic Method)
파이썬의 매직 메소드는 클래스 내에서 특정 기능을 수행하기 위해 미리 정의된 메소드를 말한다.

메소드 중 __ 로 시작해서 로 끝나는 메소드들이 있는데 예시로 **__init**__ **__str**__ **__contains**__ 등과 같은 형태로 나타난다.

이러한 매직 메소드들은 파이썬의 다양한 내장 함수나 연산자가 해당 객체와 상호 작용할 때 호출되며, 이를 통해 객체의 동작을 유연하게 커스터마이징할 수 있게 된다.

예컨대 ‘in’ 연산자는 내부적으로 **__contains**__ 매직 메소드를 찾고 호출한다.

### ‘in’ 연산자와 List 자료형

파이썬에서 ‘a in b’ 구문이 수행될 때, 내부적으로 가장 먼저 b.**__contains**__(a)가 구현되어 있는지를 확인한다.

- 만약 **__contains**__ 메서드가 정의되어 있다면, 그 메소드를 바로 호출하여 그 결과(True/False)에 따라 ‘in’ 연산의 결과가 결정된다.
- **__contains**__ 가 없을 경우, 파이썬은 b가 이터러블(iterable)인지 확인한 뒤, for 루프를 돌며 하나씩 a == 요소를 비교해 가며 포함 여부를 판별한다.

## 즉, ‘in’ 연산자는 내부적으로 __**contains**__ 에 우선순위를 두고 동작하며, 만약 구현이 없다면 반복(iteration)을 통해 동작한다.
---

## 4. 이터레이터(Iterator)와 제너레이터(Generator)
반복 가능한 객체를 어떻게 효율적으로 만드는가에 대한 개념입니다.

### 🔹 이터레이터 (Iterator)
* `__iter__`와 `__next__` 매직 메소드를 구현한 객체입니다. 데이터를 하나씩 꺼내오는 '포인터' 역할을 합니다.

### 🔹 제너레이터 (Generator): 지연 평가(Lazy Evaluation)
* `yield` 키워드를 사용하여 이터레이터를 쉽게 만드는 특별한 함수입니다.
* **핵심 원리:** 데이터를 미리 다 만들어 메모리에 쌓지 않고, 필요한 시점(`next()` 호출 시점)에만 하나씩 생성합니다.
* **yield의 역할:** `return`과 달리 함수의 상태를 **'일시 정지'** 시킨 채 값을 반환하며, 다시 호출하면 멈춘 지점부터 다시 실행됩니다.

### 🔹 10억 개의 데이터 처리: List vs Generator
* **리스트 (List):** 10억 개의 데이터를 담을 메모리 공간이 통째로 필요합니다. 메모리 부족(Out of Memory)으로 프로그램이 종료될 위험이 큽니다.
* **제너레이터 (Generator):** 10억 번을 돌더라도 메모리에는 **지금 당장 꺼낸 숫자 1개**만 올라갑니다. 메모리 용량과 상관없이 실행이 가능합니다.

> **Q: 인덱싱이 되는 리스트가 더 좋은 것 아닌가?**
> 메모리에 올릴 수만 있다면 리스트가 빠르고 편리합니다. 하지만 현실적인 **메모리(RAM)라는 그릇의 크기** 때문에 대용량 데이터에서는 제너레이터를 쓸 수밖에 없는 상황이 생깁니다.


### yield란 무엇일까? - 제너레이터와의 관계

yield는 Pyton의 함수에서 데이터를 반환하고 함수의 상태를 유지하는 키워드이다. yield를 만나면 함수는 그 시점에서 잠시 멈추고, 그 값을 반환한 후 필요할 때 다시 실행한다.
